(load "driv.scm")
(load "2-4-3.scm")
(define (deriv exp var)
   (cond ((number? exp) 0)
         ((variable? exp) (if (same-variable? exp var) 1 0))
         (else ((get 'deriv (operator exp)) (operands exp)
                                            var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (install-biop-package)
	(define (fir operands) (car operands))
	(define (sec operands ) (cadr operands))
	(define (make-operands x y) (cons x y))
	(define (make-sum x y)
       (cond ((=number? x 0) y)
       ((=number? y 0) x)
       ((and (number? x) (number? y)) (+ x y))
       (else (attach-tag '+ (make-operands x y)))))
    (define(make-product x y)
      (cond((or (=number? x 0) (=number? y 0)) 0)
      ((=number? x 1) y)
         ((=number? y 1) x)
         ((and (number? x) (number? y)) (* x y))
         (else (attach-tag '* (make-operands x y)))))
    (define( make-exp x n)
      (cond((= n 0) 1)
      ((= n 1) x)
      (else (attach-tag '** (make-operands x n)))))
	;(put 'fir '* fir)
	;(put 'sec '* sec)
	(put 'deriv '** (lambda (operands var) (make-product (sec operands) 
		 (make-product (make-exp (fir operands) (- (sec operands) 1)) 
		  (deriv (fir operands) var)))))
	(put 'deriv '+  (lambda (operands var)
		 (make-sum  (deriv (fir operands) var) (deriv (sec  operands) var ))))
	(put 'deriv '*  (lambda(operands var)
		 (make-sum (make-product (fir operands) (deriv (sec operands) var ))
		 (make-product (sec operands) (deriv (fir operands) var )))))
	'done)
